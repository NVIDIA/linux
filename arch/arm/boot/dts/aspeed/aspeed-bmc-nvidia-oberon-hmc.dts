// SPDX-License-Identifier: GPL-2.0+
/dts-v1/;

#include "nvidia-oberon-hmc-core.dtsi"
#include <dt-bindings/leds/common.h>

/ {
	model = "AST2600 Oberon HMC";
	compatible = "aspeed,ast2600";

	aliases {
		serial4 = &uart5;
	};

	chosen {
		stdout-path = &uart5;
		bootargs = "console=tty0 console=ttyS4,115200 earlyprintk";
	};

	memory@80000000 {
		reg = <0x80000000 0x40000000>;
	};

	reserved-memory {
		#address-cells = <1>;
		#size-cells = <1>;
		ranges;

		ramoops@a0000000 {
			compatible = "ramoops";
			reg = <0xa0000000 0x100000>; /* 1MB */
			record-size = <0x10000>; /* 64KB */
			max-reason = <2>; /* KMSG_DUMP_OOPS */
		};

		mctp_reserved: mctp_reserved@b1000000 {
			reg = <0xb1000000 0x40000>; /* 256KB */
			compatible = "shared-dma-pool";
			no-map;
		};
	};

        power-gpios{
                n2-gpios = <&gpio0 ASPEED_GPIO(N, 2) (GPIO_ACTIVE_HIGH|GPIO_PULL_UP)>;
                n3-gpios = <&gpio0 ASPEED_GPIO(N, 3) (GPIO_ACTIVE_HIGH|GPIO_PULL_UP)>;
        };
        leds {
            compatible = "gpio-leds";
            // Non-LEDs:
            //   HMC_READY-O GPIO pin (not an LED) is being bound to the GPIO LED driver.
            // Notes:
            // * This a workaround and leverages the GPIO LED driver to enable control of
            //   reset tolerance and still allow the GPIO to be controlled from user space.
            // * The standard Linux GPIO driver allows control of reset tolerance, however
            //   does not expose user space APIs for user space control of the GPIO pin.
            // * GPIO_TRANSITORY = reset tolerance is disabled
            // * Any non-leds should be added below this line.
            hmc_ready_noled {
                gpios = <&gpio0 ASPEED_GPIO(M, 5) (GPIO_ACTIVE_HIGH|GPIO_TRANSITORY)>;
            };
        };
};





&fmc {
    status = "okay";
    flash@0 {
        status = "okay";
        compatible = "jedec,spi-nor";
        label = "bmc";
        spi-max-frequency = <50000000>;
#include "aspeed-bmc-nvidia-gh-flash-layout-64.dtsi"
    };
};

&fmcraw {
    status = "okay";
    spidev@0 {
        compatible = "hgx,glacier";
        status = "okay";
    };
};

&spi1raw {
    status = "okay";
    pinctrl-names = "default";
    pinctrl-0 = <&pinctrl_spi1_default>;
    spidev@0 {
        spi-max-frequency = <1000000>;
        compatible = "hgx,glacier";
        status = "okay";
    };
};

&spi2 {
    status = "okay";
    pinctrl-names = "default";
    pinctrl-0 = <&pinctrl_spi2_default>;

    // Data SPI is 64MB in size
    flash@0 {
        status = "okay";
        label = "config";
        spi-max-frequency = <50000000>;
        partitions {
            compatible = "fixed-partitions";
            #address-cells = <1>;
            #size-cells = <1>;

            u-boot-env@0 {
                reg = <0x0 0x40000>;            // 256KB at offset 0
                label = "u-boot-env";
            };

            rwfs@40000 {
                reg = <0x40000 0x1000000>;      // 16MB at offset 0x40000
                label = "rwfs";
            };

            log@0x1040000 {
                reg = <0x1040000 0x2800000>;    // 40MB at offset 0x1040000
                label = "log";                  // Move log to EMMC, make this unused
            };
        };
    };
};

&rtc {
        status = "okay";
};


&uart5 {
	// BMC Debug Console
	status = "okay";
};

/*
 * Enable port A as device (via the virtual hub) and port B as
 * host by default on the eval board. This can be easily changed
 * by replacing the override below with &ehci0 { ... } to enable
 * host on both ports.
 */
&vhub {
   status = "okay";
};
// USB 2.0 to HMC & Host BMC connectivity
&udc {
    status = "okay";
};

&i2c0 {             
    status = "okay";
    bus-frequency = <400000>;
};                  


&i2c1 {
    status = "okay";
    bus-frequency = <400000>;
        eeprom@53 {
        compatible = "atmel,24c512";
               reg = <0x53>;
               pagesize = <128>;
               size = <65536>;
            };
};

&i2c2 {             
    status = "okay";
    bus-frequency = <400000>;
};                  
&i2c3 {
    status = "okay";
    bus-frequency = <400000>;
    multi-master;
};
&i2c4 {
    status = "okay";
    bus-frequency = <400000>;
};
&i2c5 {
    status = "disabled";
};
&i2c6 {
    status = "okay";
    bus-frequency = <400000>;
};
&i2c7 {
    status = "disabled";
};
&i2c8 {
    status = "okay";
};
&i2c9 {
    status = "disabled";
};
&i2c10 {
    status = "disabled";
};
&i2c11 {
    status = "disabled";
};
&i2c12 {
    status = "okay";
    bus-frequency = <400000>;
};
&i2c13 {
    status = "disabled";
};
&i2c14 {
    status = "disabled";
};
&i2c15 {
    status = "disabled";
};

// PCIe RC
&pcie {
        status = "okay";

        interrupts = <GIC_SPI 168 IRQ_TYPE_LEVEL_HIGH>;

        pcie_intc0: legacy-interrupt-controller {
                interrupts = <GIC_SPI 168 IRQ_TYPE_EDGE_RISING>;
        };
};
// Bridge between AHB bus and PCIe RC.
&h2x {
        status = "okay";
};

&mctp {
    status = "okay";
    memory-region = <&mctp_reserved>;
};

&jtag0 {
    mux-gpios = <&gpio0 186 (GPIO_ACTIVE_HIGH | GPIO_PULL_UP)>;
    status = "okay";
};

// Enable emmc
&emmc_controller {
    status = "okay";
};

&emmc {
    non-removable;
    bus-width = <8>;
    pinctrl-0 = <&pinctrl_emmcg8_default>;
    clk-phase-mmc-hs200 = <9>, <225>;
    max-frequency = <200000000>;
};

&rng {
        status = "okay";
};
